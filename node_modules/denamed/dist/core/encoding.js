"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeMessage = exports.getEncodedSize = exports.encodeNsText = exports.encodeIp6 = exports.encodeIp4 = exports.encodeSrvRecord = exports.encodeSoaRecord = exports.encodeMxRecord = exports.encodeDnsRecord = exports.encodeNsName = exports.encodeFlags = void 0;
const protocol_1 = require("./protocol");
const ip_1 = require("./ip");
const encodeFlags = (buffer, offset, message) => {
    const v = message;
    let f = 0x0000;
    f = f | (v.queryResponse << 15);
    f = f | (v.operationCode << 11);
    f = f | (v.authoritativeAnswer << 10);
    f = f | (v.truncation << 9);
    f = f | (v.recursionDesired << 8);
    f = f | (v.recursionAvailable << 7);
    f = f | (0 << 6); //Z flag
    f = f | (v.authenticatedData << 5);
    f = f | (v.checkingDisabled << 4);
    f = f | v.responseCode;
    buffer.writeUInt16BE(f, offset);
    return buffer;
};
exports.encodeFlags = encodeFlags;
const encodeNsName = (buffer, offset, name) => {
    if (!buffer.nameOffsets[name]) {
        buffer.nameOffsets[name] = offset;
    }
    else {
        buffer.writeUInt16BE(buffer.nameOffsets[name] | 0xc000, offset);
        return 2;
    }
    const n = name.split(/\./);
    let o = offset; //offset
    n.forEach((item) => {
        const l = item.length;
        buffer[o] = l;
        buffer.write(item, ++o, l, "utf8");
        o += l;
    });
    buffer[o] = 0x00;
    return n.toString().length + 2;
};
exports.encodeNsName = encodeNsName;
const encodeDnsRecord = (buffer, offset, v) => {
    let length = 0;
    offset += 2;
    switch (v.type) {
        case "A":
            length = exports.encodeIp4(buffer, offset, v.target);
            break;
        case "CNAME":
        case "NS":
            length = exports.encodeNsName(buffer, offset, v.target);
            break;
        case "SOA":
            length = exports.encodeSoaRecord(buffer, offset, v);
            break;
        case "MX":
            length = exports.encodeMxRecord(buffer, offset, v);
            break;
        case "TXT":
            length = exports.encodeNsText(buffer, offset, v.target);
            break;
        case "AAAA":
            length = exports.encodeIp6(buffer, offset, v.target);
            break;
        case "SRV":
            length = exports.encodeSrvRecord(buffer, offset, v);
            break;
        default:
            throw new Error("unrecognized nsdata type");
    }
    buffer.writeUInt16BE(length, offset - 2);
    return length + 2;
};
exports.encodeDnsRecord = encodeDnsRecord;
const encodeMxRecord = (buffer, offset, record) => {
    buffer.writeUInt16BE(record.priority, offset);
    return exports.encodeNsName(buffer, offset + 2, record.exchange) + 2;
};
exports.encodeMxRecord = encodeMxRecord;
const encodeSoaRecord = (buffer, offset, record) => {
    let o = offset;
    o += exports.encodeNsName(buffer, o, record.host);
    o += exports.encodeNsName(buffer, o, record.admin);
    // Not super readable, but writeUInt32BE returns the new offset, so taking advantage of that with nested calls
    return (buffer.writeUInt32BE(record.ttl, buffer.writeUInt32BE(record.expire, buffer.writeUInt32BE(record.retry, buffer.writeUInt32BE(record.refresh, buffer.writeUInt32BE(record.serial, o))))) - offset);
};
exports.encodeSoaRecord = encodeSoaRecord;
const encodeSrvRecord = (buffer, offset, record) => {
    return (exports.encodeNsName(buffer, buffer.writeUInt16BE(record.port, buffer.writeUInt16BE(record.weight, buffer.writeUInt16BE(record.priority, offset))), record.target) + 6);
};
exports.encodeSrvRecord = encodeSrvRecord;
const encodeIp4 = (b, offset, ipAddress) => {
    b.writeUInt32BE(ip_1.ipV4ToDecimal(ipAddress), offset);
    return 4;
};
exports.encodeIp4 = encodeIp4;
const encodeIp6 = (b, offset, v) => {
    const a = ip_1.parseIPv6(v);
    for (let i = 0; i < 8; i++) {
        b.writeUInt16BE(a[i], offset + i * 2);
    }
    return 16;
};
exports.encodeIp6 = encodeIp6;
const encodeNsText = (b, offset, v) => {
    b.writeUInt8(v.length, offset);
    return b.write(v, offset + 1) + 1;
};
exports.encodeNsText = encodeNsText;
// Haven't tested what is faster, creating a bunch of buffers concatenating or the single allocation with a calc method.
// This can probably be optimized as well, my assumption is this strategy is faster however it may be a premature optimization
function getEncodedSize(message) {
    let length = 12;
    let cache = {};
    const calcName = (name) => {
        if (cache[name])
            return 2;
        return (cache[name] = name.split(".").toString().length + 2);
    };
    message.questions?.forEach((question) => {
        length += 4 + calcName(question.name);
    });
    [message.answers, message.authorities, message.additional].forEach((a) => {
        a?.forEach((answer) => {
            length += 10 + calcName(answer.name);
            switch (answer.type) {
                case "A":
                    length += 4;
                    break;
                case "AAAA":
                    length += 16;
                    break;
                case "CNAME":
                case "NS":
                case "TXT":
                    length +=
                        answer.data.target.split(".").toString()
                            .length + 2;
                    break;
                case "SOA":
                    length +=
                        calcName(answer.data.host) + calcName(answer.data.admin) + 20;
                    break;
                case "SRV":
                    length += calcName(answer.data.target) + 6;
                    break;
                case "MX":
                    length += calcName(answer.data.exchange) + 2;
                    break;
                default:
                    throw new Error(`Unsupported type ${answer.type}`);
            }
        });
    });
    return length;
}
exports.getEncodedSize = getEncodedSize;
function encodeMessage(message) {
    const headerSize = 12;
    const buffer = Buffer.allocUnsafe(getEncodedSize(message));
    buffer.nameOffsets = {};
    buffer.writeUInt16BE(message.id, 0);
    exports.encodeFlags(buffer, 2, message);
    buffer.writeUInt16BE(message.questions?.length ?? 0, 4);
    buffer.writeUInt16BE(message.answers?.length ?? 0, 6);
    buffer.writeUInt16BE(message.authorities?.length ?? 0, 8);
    buffer.writeUInt16BE(message.additional?.length ?? 0, 10);
    let offset = headerSize;
    message.questions?.forEach((question) => {
        offset += exports.encodeNsName(buffer, offset, question.name);
        offset = buffer.writeUInt16BE(protocol_1.QueryTypes[question.type], offset);
        offset = buffer.writeUInt16BE(protocol_1.DnsClass.Internet, offset);
    });
    [message.answers, message.authorities, message.additional].forEach((a) => {
        a?.forEach((answer) => {
            offset += exports.encodeNsName(buffer, offset, answer.name);
            offset = buffer.writeUInt16BE(protocol_1.QueryTypes[answer.type], offset);
            offset = buffer.writeUInt16BE(protocol_1.DnsClass.Internet, offset);
            offset = buffer.writeUInt32BE(answer.ttl, offset);
            offset += exports.encodeDnsRecord(buffer, offset, answer.data);
        });
    });
    return buffer;
}
exports.encodeMessage = encodeMessage;
//# sourceMappingURL=encoding.js.map