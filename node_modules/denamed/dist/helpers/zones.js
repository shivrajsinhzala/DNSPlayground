"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useZone = void 0;
const query_1 = require("../query");
const answers_1 = require("../core/answers");
function expandZone(zone) {
    const newZone = { tld: zone.tld };
    ['a', 'txt', 'cname', 'mx', 'ns', 'aaaa'].forEach(key => {
        if (zone[key]) {
            newZone[key] = {};
            Object.keys(zone[key]).forEach(name => {
                const value = zone[key][name];
                newZone[key][(name.endsWith(zone.tld) ? name : name + '.' + zone.tld)] = typeof value === 'string' ? { value } : value;
            });
        }
    });
    return newZone;
}
function matchAnswerInZone(expandedZone, question) {
    if (question.name.endsWith(expandedZone.tld)) {
        switch (question.type) {
            case "A":
                {
                    const match = expandedZone.a?.[question.name];
                    if (match)
                        return answers_1.createAAnswer(question, match.value, match.ttl ?? expandedZone.ttl);
                }
                break;
            case "NS":
                {
                    const match = expandedZone.ns?.[question.name];
                    if (match)
                        return answers_1.createNSAnswer(question, match.value, match.ttl ?? expandedZone.ttl);
                }
                break;
            case "MX":
                {
                    const match = expandedZone.mx?.[question.name];
                    if (match)
                        return answers_1.createMxAnswer(question, match.value, match.priority, match.ttl ?? expandedZone.ttl);
                }
                break;
            case "TXT":
                {
                    const match = expandedZone.txt?.[question.name];
                    if (match)
                        return answers_1.createTxtAnswer(question, match.value, match.ttl ?? expandedZone.ttl);
                }
                break;
            case "CNAME":
                {
                    const match = expandedZone.cname?.[question.name];
                    if (match)
                        return answers_1.createCnameAnswer(question, match.value, match.ttl ?? expandedZone.ttl);
                }
                break;
            case "AAAA":
                {
                    const match = expandedZone.aaaa?.[question.name];
                    if (match)
                        return answers_1.createAaaaAnswer(question, match.value, match.ttl ?? expandedZone.ttl);
                }
                break;
        }
    }
}
function useZone(zone) {
    const expandedZone = expandZone(zone);
    return (query) => {
        const answers = query.questions?.map(question => matchAnswerInZone(expandedZone, question));
        if (answers?.every(a => a)) {
            return query_1.createResponse(query, answers);
        }
    };
}
exports.useZone = useZone;
//# sourceMappingURL=zones.js.map