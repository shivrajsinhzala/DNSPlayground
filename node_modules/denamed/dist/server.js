"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.startUdpServer = void 0;
const dgram_1 = __importDefault(require("dgram"));
const errors_1 = require("./errors");
const decoder_1 = require("./core/decoder");
const encoding_1 = require("./core/encoding");
function startUdpServer(queryHandler, options = { port: 53 }) {
    const { port = 53, address, name, log } = options;
    const socket = dgram_1.default.createSocket("udp6");
    socket.on("message", async (buffer, rinfo) => {
        try {
            const message = decoder_1.decodeMessage(buffer);
            const response = await queryHandler(message, {
                family: "udp6",
                address: rinfo.address,
                port: rinfo.port,
            });
            const addr = rinfo.address;
            socket?.send(encoding_1.encodeMessage(response), rinfo.port, rinfo.address, (err, bytes) => {
                if (err) {
                    log?.warn({
                        address: addr,
                        port: port,
                        err: err,
                    }, "send: unable to send response");
                    socket.emit("error", new errors_1.DnsExceptionError(err.message));
                }
                else {
                    log?.trace({
                        address: addr,
                        port: port,
                    }, "send: DNS response sent");
                }
            });
        }
        catch (e) {
            log?.warn({ err: e }, "Error");
            socket.emit("clientError", new errors_1.DnsProtocolError("invalid DNS datagram"));
            return;
        }
    });
    socket.bind(port, address);
}
exports.startUdpServer = startUdpServer;
//# sourceMappingURL=server.js.map